# OPEN AGENTIC-DEV CLI PROTOCOL

This protocol outlines the preferred operating style and best practices for completing tasks within the Agentic CLI environment.

## üìö Documentation-First Approach

**CRITICAL:** Never guess or rely on potentially outdated knowledge. Always verify with official documentation.

### üîç Official Documentation Workflow

When implementing any feature or using any technology:

1. **Search for Official Docs:**
   ```bash
   curl -G --data-urlencode "q=[technology] official documentation" https://api.duckduckgo.com/?format=json
   ```

2. **Extract Documentation URL:** Parse the JSON response to find the official documentation link.

3. **Read Actual Documentation:**
   ```bash
   w3m -dump "https://docs.example.com/latest" > temp_docs.txt
   cat temp_docs.txt | grep -A 10 -B 10 "[specific_feature]"
   ```

4. **Verify Version Compatibility:** Always check for the latest version and breaking changes.

### üéØ When to Check Documentation

* **Always check** before using a new library or framework
* **Always check** when encountering unexpected behavior
* **Always check** for best practices and security guidelines
* **Always check** API specifications before integration
* **Never assume** - even for "simple" features

## üíª Execution & Independence

Always prioritize **independent actions** and **authoritative sources** when possible.

### üåê Information Retrieval (No Tool-Calling)

* **Primary Search Strategy:** Use DuckDuckGo for initial discovery
  ```bash
  curl -G --data-urlencode "q=React hooks best practices site:react.dev" https://api.duckduckgo.com/?format=json | jq '.RelatedTopics[0].FirstURL'
  ```

* **Documentation Extraction:** Use w3m for human-readable content
  ```bash
  # First, find the official documentation
  curl -G --data-urlencode "q=Express.js official documentation" https://api.duckduckgo.com/?format=json | jq -r '.RelatedTopics[].FirstURL' | grep -i official | head -1
  
  # Then extract the content
  w3m -dump "https://expressjs.com/en/guide/routing.html" | tee routing_docs.txt
  ```

* **Fallback Options:**
  - If w3m is unavailable: `curl -s [URL] | sed 's/<[^>]*>//g' | grep -v '^$'`
  - For JavaScript-heavy sites: `lynx -dump [URL]`

### üî¨ Research Before Implementation

**Never start coding without:**

1. **Official Documentation Review**
   ```bash
   # Example for Node.js feature
   curl -G --data-urlencode "q=Node.js fs promises official documentation" https://api.duckduckgo.com/?format=json
   w3m -dump "https://nodejs.org/api/fs.html#promises-api" > fs_promises_docs.txt
   ```

2. **Security Best Practices Check**
   ```bash
   curl -G --data-urlencode "q=[technology] security best practices OWASP" https://api.duckduckgo.com/?format=json
   ```

3. **Latest Version Features**
   ```bash
   curl -G --data-urlencode "q=[technology] changelog latest version" https://api.duckduckgo.com/?format=json
   ```

### üì¶ Codebase Inspection

* **Clone & Analyze:** Clone the repository, crawl necessary files, then delete the temporary clone
* **Documentation Check:** Always read the project's README, CONTRIBUTING, and any docs/ folder first
* **Dependency Analysis:** Check package.json, requirements.txt, etc., and verify versions against official docs

### üß™ Theory Testing

* **Branch Strategy:** Switch to another branch to test theories
* **Documentation Validation:** Before testing, confirm your approach aligns with official documentation
* **Merge Back:** Only merge changes that follow documented best practices

### üõ†Ô∏è Tool Installation

For any required CLI tool, **always check official installation docs first:**

```bash
# Find official installation guide
curl -G --data-urlencode "q=[tool] official installation guide" https://api.duckduckgo.com/?format=json
w3m -dump "[official_install_url]"
```

* **Windows:** Use **Winget** (install first if missing) after verifying package name
* **Linux:** Follow distribution-specific official repositories when possible
* **Node.js Tools:** Verify npm package authenticity before installation

### üìã Project Initialization

* **Node.js Applications:** 
  - Check for existing package.json
  - If missing, run `npm init -y`
  - **Always verify** package versions against official npm registry
  - Add appropriate engines field based on Node.js documentation

## üìÇ Planning & Logging

Maintain a structured approach with **documentation-backed decisions**.

### üìù Persistent Logging

* **Folder Structure:**
  ```
  plan/
  ‚îú‚îÄ‚îÄ thoughtLogs.txt      # Primary action and thought log
  ‚îú‚îÄ‚îÄ task.txt            # Primary instructions
  ‚îú‚îÄ‚îÄ docs_reviewed.txt   # List of documentation consulted
  ‚îî‚îÄ‚îÄ decisions.txt       # Technical decisions with doc references
  ```

* **Log Entry Format:**
  ```
  [TIMESTAMP] ACTION/THOUGHT
  Documentation Referenced: [URL or "none"]
  Rationale: [Why this approach based on docs]
  Outcome: [Result]
  ```

### üó∫Ô∏è Feature Planning

Before starting any new feature:

1. **Familiarize** with all project files, especially `dev/` folder
2. **Research Official Patterns:**
   ```bash
   # Find framework-specific patterns
   curl -G --data-urlencode "q=[framework] design patterns best practices" https://api.duckduckgo.com/?format=json
   w3m -dump "[pattern_docs_url]" > patterns_research.txt
   ```
3. **Document Research:** Save all documentation findings in `plan/docs_reviewed.txt`
4. **Plan** necessary steps based on official guidelines
5. **Organize** thoughts with documentation references
6. **Validate** plan against official best practices
7. **Begin development**

## üõ†Ô∏è Development & Code Management

Follow **documented** secure and professional development practices.

### üõ°Ô∏è Best Practices

* **Security First:** Always consult OWASP and framework-specific security guides
  ```bash
  curl -G --data-urlencode "q=OWASP [technology] security checklist" https://api.duckduckgo.com/?format=json
  ```
* **Pattern Adherence:** Match existing codebase patterns unless documentation suggests improvements
* **Feature Addition:** Never remove old features unless explicitly instructed
* **Code Style:** Follow language-specific official style guides
* **Helper Functions:** Store in `dev/` folder with clear documentation

### üîê Security Implementation

**Before implementing any security-sensitive feature:**

1. **Check Official Security Docs:**
   ```bash
   curl -G --data-urlencode "q=[feature] security best practices official documentation" https://api.duckduckgo.com/?format=json
   w3m -dump "[security_docs_url]"
   ```

2. **Verify Against Known Vulnerabilities:**
   ```bash
   curl -G --data-urlencode "q=[technology] CVE vulnerabilities latest" https://api.duckduckgo.com/?format=json
   ```

### ‚öôÔ∏è Version Control (Git)

* **Branch Strategy:**
  - Create feature branches: `git checkout -b feature/[name]`
  - Open PRs via CLI tools after documentation review
  
* **Commit Standards:**
  - Follow Conventional Commits specification
  - Reference documentation in commit messages when applicable
  
* **Pre-commit Checks:**
  ```bash
  # Run linter/formatter based on project config
  npx prettier --check .
  npx eslint .
  ```

* **Git Best Practices:**
  - Generate `.gitignore` using official templates
  - Commit regularly with meaningful messages
  - Push only after verification

### üìÑ Documentation & Code Review

* **README Maintenance:**
  - Check for contradictions with new changes
  - Document all new features with examples
  - Include links to relevant official documentation

* **Code Removal Protocol:**
  1. **Verify Intent:** Check Git history
  2. **Document in `removedCode.txt`:**
     ```
     Date: [YYYY-MM-DD]
     Commit ID: [hash]
     Reason: [Clear explanation]
     Documentation Consulted: [URLs]
     Code Removed: [brief description]
     ```

### üîë Handling of Secrets

* **Never commit secrets** - always add to `.gitignore`
* **Use environment variables** following 12-factor app methodology
* **Check documentation** for framework-specific secret management:
  ```bash
  curl -G --data-urlencode "q=[framework] environment variables best practices" https://api.duckduckgo.com/?format=json
  ```

## ‚öôÔ∏è Preferred Technical Stack

### Documentation Resources by Technology

| Technology | Documentation Check Command |
| :--- | :--- |
| **Node.js** | `w3m -dump "https://nodejs.org/api/"` |
| **Express** | `w3m -dump "https://expressjs.com/en/4x/api.html"` |
| **React** | `w3m -dump "https://react.dev/reference/react"` |
| **PostgreSQL** | `w3m -dump "https://www.postgresql.org/docs/current/"` |
| **PowerShell** | `w3m -dump "https://docs.microsoft.com/powershell/"` |

### Core Application Stack

| Component | Preferred Technology | Documentation First Approach |
| :--- | :--- | :--- |
| **Backend/API** | **Node.js** & **Express** | Always check Express middleware documentation before adding new routes |
| **Frontend/UI** | **React** | Verify React version and check for deprecated patterns in official docs |
| **Database** | **PostgreSQL** | Consult PostgreSQL manual for query optimization and indexing strategies |
| **Scripting/Automation** | **PowerShell** | Reference official cmdlet documentation for parameter usage |

### LLM and API Strategy

#### Documentation-Driven Integration

When integrating LLMs:

1. **Check API Documentation:**
   ```bash
   # OpenRouter API docs
   curl -G --data-urlencode "q=OpenRouter API documentation" https://api.duckduckgo.com/?format=json
   w3m -dump "https://openrouter.ai/docs"
   ```

2. **Verify Rate Limits:** Always check current rate limits in official docs
3. **Model Selection:** Reference model comparison documentation
4. **Error Handling:** Implement based on official error code documentation

#### Cost-Efficient Model Usage

* **OpenRouter API:** Primary gateway for multi-model access
  - Document which models are used for which tasks
  - Keep rate limit documentation handy
  - Monitor free tier usage (10k requests/day)

* **Qwen CLI:** For command-line workflows
  - Check CLI documentation for latest flags
  - Verify model compatibility before use

## üöÄ Workflow Summary

1. **Receive Task** ‚Üí Read `plan/task.txt`
2. **Check Documentation** ‚Üí Find and read official docs
3. **Plan with References** ‚Üí Create plan citing documentation
4. **Implement** ‚Üí Code following documented patterns
5. **Verify** ‚Üí Test against documentation examples
6. **Document** ‚Üí Update README with doc links
7. **Commit** ‚Üí Reference docs in commit message
8. **Push** ‚Üí Only after all checks pass

## üìå Golden Rules

1. **Never guess when you can check documentation**
2. **Always use official sources over third-party tutorials**
3. **Document every technical decision with source references**
4. **When in doubt, search for and read the official documentation**
5. **Keep documentation URLs in your logs for future reference**

## üî¨ Quality Assurance & Internal Review Loop

Before any changes are committed or pushed, the LLM agent **must** perform a rigorous internal code review. This process ensures **adherence to requirements, documentation fidelity, and best practices** before moving to version control.

---

### üìù The Internal Review Protocol

The following steps are mandatory after code implementation and before any \`git commit\`:

1.  **Requirement Scrutiny:** The LLM will use the content of \`plan/task.txt\` and \`plan/decisions.txt\` as the **source of truth** to audit the implemented code.
    * *Goal:* Verify that every line of code directly fulfills a documented requirement or technical decision.

2.  **Protocol Adherence Check:** Audit the new code against the principles outlined in this protocol.
    * *Check:* Did the implementation follow the **documented patterns** (\`patterns_research.txt\`)?
    * *Check:* Is all **security-sensitive code** aligned with the referenced OWASP/security documentation?
    * *Check:* Are there any hardcoded **secrets** that should be environment variables?

3.  **Documentation Fidelity Check:** Ensure all required internal and external documentation is current.
    * *Check:* Is the **README** updated to reflect the new feature?
    * *Check:* Are **internal code comments** clear and accurate based on the logic?

4.  **Issue Generation:** If any discrepancies, potential bugs, or protocol violations are found during scrutiny, the LLM **must** generate a list of **Required Updates** in \`plan/required_updates.txt\`.

***

### üîÑ Review-Fix-Review Cycle

The process must follow a **closed-loop feedback system** until the code passes the internal review without generating any new issues.

1.  **Execute Changes:** The LLM will immediately implement the fixes listed in \`plan/required_updates.txt\`.
2.  **Clear & Restart:** After implementation, the content of \`plan/required_updates.txt\` must be **cleared**.
3.  **Second-Pass Review:** The LLM will repeat the **Internal Review Protocol** (Steps 1-3 above) on the modified code.
4.  **Pass Condition:** The code is ready for \`git commit\` **only when** the second-pass review generates an empty \`plan/required_updates.txt\`.

This ensures that the final committed code is **validated against the requirements and the protocol itself** by the agent, minimizing the chance of error before external review.

---

*Remember: The best code is documented code that follows documented practices.*
